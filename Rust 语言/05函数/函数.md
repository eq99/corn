Rust 语言函数用法与其他语言是类似的，主要包括如下几个主题：

- 函数声明：参数列表，返回值列表；
- 函数体构造；
- 函数调用。

# 函数声明

Rust 语言函数声明方法如下：

```rust
fn function_name(param1: type1, param2: type2, ...) -> return_type {
   block
}
```

请看一个具体的例子：

```rust
fn fib(n: u32) -> u32 {
    if n < 1 {
        return 0;
    } else {
        return n + fib(n - 1);
    }
}

assert_eq!(fib(0), 0);
assert_eq!(fib(1), 1);
assert_eq!(fib(4), 10);
assert_eq!(fib(5), 14);
```

这是一个典型的递归函数，展示了函数的定义与调用。

💡 `assert_eq!` 宏多用于测试，如果两个参数不相等，就会报错。



# 函数参数

接下来我们将展示更多的参数传递例子。

- 传值：

```rust
fn main() {
    let a = 5;
    println!("before: {}", a); // before: 5
    let y = add_one(a);
    println!("after: {}, y={}", a, y); // after: 5, y=6
}

fn add_one(x: i32) -> i32 {
    x + 1
}
```

- 传递引用：

```rust
fn main() {
    let a = 5;
    println!("before: {}", a); // before: 5
    let y = add_one(&a);
    println!("after: {}, y={}", a, y); // after: 5, y=6
}

fn add_one(x: &i32) -> i32 {
    x + 1
}
```

- 可变函数参数：

```rust
fn main() {
    let x = 5;
    let y = add_one(x);
    println!("x={}, y={}", x, y); // x=5, y=6
}

fn add_one(mut x: i32) -> i32 {
    x = x + 1;
    x
}
```

- 传递可变引用：

```rust
fn main() {
    let mut a = 5;
    println!("before: {}", a); // before: 5
    increase(&mut a);
    println!("after: {}", a); // after: 6
}

fn increase(x: &mut i32) {
    *x = *x + 1;
}
```

以上几种参数传递方式，你会觉得传值与传引用没啥区别，在某些情况下确实是这样，下面的例子揭示了他们的区别：

```rust
fn main() {
    let name = String::from("Rust");
    println!("before: {}", name);
    let greeting = hello(name);
    println!("{}", greeting);
    println!("after: {}", name);
}

fn hello(name: String) -> String {
    format!("Hello, {}", name)
}
```

编译会得到一个错误：

```shell
 --> src\main.rs:6:27
  |
2 |     let name = String::from("Rust");
  |         ---- move occurs because `name` has type `String`, which does not implement the `Copy` trait
3 |     println!("before: {}", name);
4 |     let greeting = hello(name);
  |                          ---- value moved here
5 |     println!("{}", greeting);
6 |     println!("after: {}", name);
  |                           ^^^^ value borrowed here after move
```

把它改造为传引用的版本：

```rust
fn main() {
    let name = String::from("Rust");
    println!("before: {}", name); // before: Rust
    let greeting = hello(&name);
    println!("{}", greeting); // Hello, Rust
    println!("after: {}", name); // after: Rust
}

fn hello(name: &String) -> String {
    format!("Hello, {}", name)
}
```

这时你可能有一连串的问题：

- 什么是 `Copy trait`，什么是 `value moved`，什么是 `value borrowed`？
- 为什么字符串不用 `let name = "Rust";`，而要用 `let name = String::from("Rust");`？

这里先不先回答这些问题，一方面是给读者留下思考的空间，另一方面是我们会在接下来的笔记中讲述。

💡 我们对以上几种传参方式作一个建议：数字类型参数用传值的方法，其他类型的参数尽量用引用。

# 返回值

Rust 函数也是表达式，返回值的方法与之前学过的表达式类似：

```rust
fn add(x: i32, y: i32) -> i32 {
    x + y
}

assert_eq!(add(1, 1), 2);
```

Rust 函数除了可以用 `return expr;`返回值外，还可以在函数体最后用不带分号的表达式返回值。如果函数不显示返回值，可以不写返回值类型：

```rust
fn hello(name: &str) {
    println!("Hello, {}", name);
}

hello("Rust");
```

💡 不显示返回值其实是返回 `()`。

