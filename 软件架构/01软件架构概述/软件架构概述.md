# 软件架构

软件架构又称软件体系结构，是用来刻画软件系统整体抽象结构的一种手段。



# 软件架构的特征

- 注重可重用性，避免重零开始
- 利益关注者较多
- 关注点分离，分而治之，模块化。
- 质量驱动：可扩展性，可靠性。
- 概念完整性：用相似的方法做相似的事情。
- 循环风格：用标准的方法处理反复出现的问题。

# 模块化基本原则

- 职责单一：一个模块尽量只完成一个功能。
- 最低耦合：也就是不同模块之间的关联尽可能少。
- 尺度合适：粒度过大造成内部维护困难，过小会导致耦合增加。
- 模块调用链不能过深。
- 接口封装得好。
- 尽可能复用已有的模块。

# 常见的架构描述方法

- 形式化的架构描述方法：基于模型，代数方法，过程代数方法，基于逻辑的方法和基于网格的方法
- Kruchten 的 “4+1” 架构模型：从五个视角：逻辑视角，过程视角，物理视角开发视角和场景视角来描述软件架构。
- 使用 UML 的架构描述方法
- IEEE 的软件架构描述规范



# 软件架构分析

软件架构分析的目的是在系统被实际构造之前预测其质量属性，分为结构分析，功能分析，和非功能分析。



# 软件架构设计方法

- 工件驱动（artifact-driven）方法
- 用例驱动（use-case-driven）方法
- 模式驱动（patten0driven）方法
- 领域驱动（domain-driven）方法



# 架构发现、演化与复用

架构发现是从现有的软件系统中提取架构。

架构演化是由于系统的需求、环境、技术、分布等因素变化而导致的软件架构变动。

架构复用属于设计重用，比代码重用更抽象。

# 基于架构开发的模型

（1）需求完全确定的瀑布模型

（2）在开发阶段只能提供基本需求时采用的渐进式开发模型

（3）以形式化开发为基础的变换模型。

# 软件架构风格

（1）数据流风格：批处理，管道，过滤，适用于流水线。

（2）调用返回风格：主程序—子程序，面向对象，层次化，适用于组件内部功能设计。

（3）独立组件：进程通信、事件系统，

（4）虚拟机风格：解释器，基于规则的系统，适用于解释器，专家系统

（5）仓库风格：数据库系统、超文本系统、黑板系统

# 领域开发特征

（1）一个严格定义的问题域/解域

（2）具有普遍性，使其可以用于领域某个特定应用的开发

（3）对整个领域的适度抽象

（4）具有该领域固定的、典型的可复用元素。



第二章 软件架构的概念



# 组成派

组成派认为软件架构主要反应系统有哪些部分组成，以及这些部分是如何组成的，强调软件系统的整体结构和配置。组成派主要思想如下：

（1）Dewayne和 Alexander：软件架构={元素，组成，原理}

（2）1993年David：软件架构主要包括组件、连接件和约束。

（3）2011年IEEE：组件，组件之间的联系，组件与环境之间的联系

# 决策派

软件架构是一系列设计决策的集合，设计其实是开发人员的意志和决策在软件开发过程中的体现。

# 参考框架

软件架构一般由五种元素构成：组件、连接件、接口、角色、配置。



第三章 软件架构模型



# 软件架构建模的方法

（1）基于非规范化的图形表示建模

（2）基于UML建模的方法

（3）基于形式化的建模方法

（4）基于UML的形式化方法

（5）其他建模方法



# UML 表达几种类的关系

（1）关联关系：分为单项、双向关联与自关联，代码表现为成员变量

（2）聚合关系：是整体与部分的关系，且部分可以离开整体而单独存在，代码表现为成员变量。

（3）组合关系：是整体与部分的关系，但部分不能离开整体而单独存在。

（4）依赖关系：表现为参数传递

（5）继承关系：又称泛化关系。

（6）接口实现：

# UML 用例图

（1）用例：即系统的功能

（2）参与者：是系统外部的参与者，可以是用户、外部硬件、其他系统，

（3）关系： 关联，包含，扩展，泛化



# 软件架构的形式建模方法

（1）基于形式化规格说明语言的建模：Z语言，B语言，VDM，Petri 网。

（2）基于 UML 的形式化建模方法：



# 其他建模方法

（1）文本语言建模方法

（2）模型驱动方法



# 软件架构建模方法发展趋势

第0层，没有标准，模型存在于开发者大脑里

第1层，文本表达，用自然语言描述

第2层，文本和图，用文本加一些图形

第3层，模型和图，用建模语言描述的图来表达模型，用自然语言加以描述

第4层，精确的模型，没有歧义，直接映射到语言

第5层，只有模型，直接生成代码



第四章 软件架构风格

# 管道过滤器风格

优点：

（1）组件功能独立，整个系统易于理解

（2）支持功能重用

（3）系统易于扩展与维护

（4）支持特殊分析，如吞吐量分析、死锁分析

（5）支持并发分析

缺点：

（1）不适用于交互性很强的系统

（2）每个过滤器可能需要对数据进行解析或编码，导致额外工作

典型应用：Unix shell 命令、信号处理、并行计算、功能编程、分布式系统、编译器。

# 主程序/子程序风格

将大系统分割为若干模块

优点：

（1）程序结构化、逻辑清晰，易于理解。

缺点：

（1）某个子过程的修改会导致其他模块的修改，导致程序可维护性以及测试困难。

# 面向对象风格

直接从可观事物出发，把问题域中的事物抽象成系统对象，作为系统中的基本单元。

优点：

（1）隐藏了对象实现细节

（2）把数据存取操作分解为可交互的代理程序集合。

缺点：

（1）需要知道对象的标识，当对象标识改变时，需要修改它的显示调用者。



# 层次化风格

把一个复杂的系统分为若干个层次，每个层次由一系列组件构成，层次之间存在接口。

优点：

（1）增量抽象

（2）支持扩展

（3）支持重用

缺点：

（1）层次化结构会损失性能

（2）定义一个合适的抽象层很困难

案例：计算机网络协议。



# 事件驱动风格

事件风格基于“隐式调用”，与面向对象的显示调用互补。

优点：

（1）组件关联较弱

（2）提高软件复用能力

（3）系统便于升级

缺点：

（1）事件发布者放弃了对计算的控制权，它不保证事件是否能被响应，也不知道如何相应

（2）存在数据交换问题

（3）正确性难以验证，因为事件常常伴随上下文



# 解释器风格

将高层次的程序翻译为低层次的指令。

优点：

（1）实现程序的可移植性与跨平台能力

（2）可以对未来二硬件进行仿真模拟

缺点：

（1）导致程序运行效率低

# 基于规则的系统

业务中需求需要频繁的变动，软件系统也随之变动，如果每次业务需求变动都需要改代码，会使得软件维护成本增加。解决办法是将频繁变动的业务抽取出来，形成独立的规则库。

一般基于XML等配置文件实现。

# 仓库风格

仓库是存储和维护数据的中心场所，由中央数据组件和相关数据操作组件构成。

优点：

（1）便于模块之间数据共享

（2）方便开发新组建

（3）减少重复

缺点：

（1）需要同步，需要保证完整性、一致性

# 客户机/服务器风格

# 浏览器/服务器风格



# 平台—插件风格

插件是遵循预定义接口规范编写出来的程序，应用程序在运行时通过接口调用插件，以扩展应用程序功能。插件最吸引人的地方使其所实现的“运行时”功能扩展。这种风格的软件主要分为两个部分：内核与插件。

优点：

（1）降低模块之间的依赖性

（2）系统模块之间独立开发、部署

（3）根据需求动态的组装、分离系统。

应用示例：IDE

# Agent 风格

# 面向切片风格（AOP）

# 面向服务架构风格



第五章 软件架构描述语言



# ADL 定义

ADL 就是任何用于软件架构的表示形式。ADL要素：

（1）组件：计算单元或数据存储单元

（2）连接件：用来建立组件之间的联系

（3）架构配置：描述组件与连接件之间的拓扑关系

（4）约束：



第七章 架构驱动的软件开发



# 架构驱动开发的基本流程

（1）架构需求获取

（2）基本架构设计

（3）架构文档化

（4）架构评估

（5）架构实现

（6）架构维护



# 通过质量模型描述架构需求



软件设计需要考虑特定质量场景：性能、可移植性、可替换性、可重用性。

软件质量理想模型：定义模型、评估模型、和预测模型。



# 架构设计过程

（1）通过功能性列表抽取架构需求列表类功能列表。

（2）选择需要开发的子系统

（3）基于功能架构完成并发架构



# 架构文档化

（1）架构文档必须完整，即使没有软件背景的工程师也能读懂。

（2）整个架构文档必须包含一个显著的起点，以此把所有的子系统连接成一个完整的集合。

（3）架构文档要考虑通信、数据分配、资源管理、时间管理等基础设施的约束。

（4）软件架构文档要像利益相关者公开。



# 架构的结构

（1）基于功能

（2）基于代码

（3）并发

（4）物理

（5）基于开发



第八章 软件架构设计与实现



# 软件架构品质

（1）良好的模块化：职责明确，低耦合，高内聚

（2） 能适应需求变化

（3）对软件的运行态有良好的规划：说明模块调用关系，说明关键进程，线程、队列与消息机制

（4）对数据有良好的规划：包括数据持久化化方案、数据复制、数据同步。

（5）明确、灵活的部署规划





# 架构设计的关键原则

（1）关注点分离

（2）单一职责原则

（3）最少知识原则

（4）不重复原则（DRY）

（5）尽量减少前期设计



# 软件架构面临的主要问题

（1）被忽略的重要非功能需求

（2）频繁变动的需求

（3）考虑不全面的架构设计

（4）不及时的架构验证

（5）较高的创造性架构比重

（6）架构的可执行性低
